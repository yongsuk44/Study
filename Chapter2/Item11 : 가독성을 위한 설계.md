# 코드 가독성을 위한 설계

---

프로그래밍에서는 코드를 작성하는 것보다 코드를 읽는 시간이 더 많다고 합니다.
즉, 코드를 작성하는데 소요되는 시간보다 그것을 읽는데 약 10배 가량의 시간이 소요된다고 합니다.(Clean Code 책에 의하면)

새로운 API를 사용하는 방법을 배울 때 대부분 코드를 읽으면서 배우게 되며,
코드를 읽음으로써 해당 로직이나 구현 방법을 이해하게 됩니다.

이러한 점을 고혀라면, 우리는 가독성을 염두하고 코드를 작성해야 합니다.

## 인지 부하 줄이기

`인지 부하`란 정보를 처리하거나 이해하는 데 필요한 정신적 노력을 의미합니다.

복잡하게 작성된 코드는 이 인지 부하를 증가시켜 개발자가 코드를 이해하고 디버깅하고 수정하는데 더 많은 시간과 노력을 요합니다.

익숙한 패턴이 반복적으로 등장하면, 개발자들은 더 빠르게 인식을 하게되고,
따라서 코드 작성 시 개발자가 이미 다른 분야에서 익숙하게 사용되고 있는 구조를 사용하는 것이 가장 좋습니다.

아래 2가지 예시를 비교해볼까요??

```kotlin
if (person != null && person.isAdult) {
    view.showPerson(person)
} else {
    view.showError()
}
```

```kotlin
person
    ?.takeIf { it.isAdult }
    ?.let(view::showPerson)
    ?: view.showError()
```

Kotlin을 처음 접하는 사람에게는 1번 방식이 더 가독성이 있을 수 있습니다.

또한, 1번 코드는 코드를 수정하기가 더 수월할것입니다.
`if` Block에 대한 추가작업이 있다고 가정하면 다음과 같이 추가로 코드를 작성하기만 하면 간단합니다.

```kotlin
if (person != null && person.isAdult) {
    view.showPerson(person)
    view.hideProgressWithSuccess()
} else {
    view.showError()
    view.hideProgressBar()
}
```

그러나, 2번 코드에는 더 이상 함수 참조를 사용할 수 없을 것입니다. 추가적인 작업을 하여야 합니다.

```kotlin
person
    ?.takeIf { it.isAdult }
    ?.let {
        view.showPerson(it)
        view.hideProgressWithSuccess()
    } ?: run {
    view.showError()
    view.hideProgressBar()
}
```

마지막으로, `if/else`를 통한 2분기가 아닌 3번째 분기를 추가해야 한다면,  
1번 구현에서는 `when`으로 변경하여 추가 분기를 쉽게 작성할 수 있으나,   
2번 구현에서는 좀 더 까다롭게 변경을 해야합니다.

---

## 극단적인 접근 피하기

이전의 예에서 `let`이 잘못 사용될 수 있음을 보였지만, 항상 피해야 한다는 의미는 아닙니다.   
`let`은 코드를 개선하기 위해 다양한 맥락에서 합리적으로 사용되는 인기 있는 관용구입니다.   
가령, nullable하고 가변적인 속성을 가지고 있을 때, 그 속성이 `null`이 아닐 경우에만 작업을 수행하려면 `let`을 사용하는 것이 좋습니다.

```kotlin
class Person(val name: String)

var person: Person? = null

fun printName() {
    person?.let { print(it.name) }
}
```

### 코드의 복잡성과 이해성
하지만 이러한 코드는 디버깅이 더 어렵고, Kotlin에 덜 익숙한 개발자들에게 이해하기 어려울 수 있습니다.   
하지만, 이것은 코드의 복잡성을 증가시키는 대가로, 이 대가를 지불하는 것은 합리적인 경우가 있습니다.
문제는 이런 복잡성이 합리적인 이유 없이 도입되는 경우입니다.

### 균형 있는 구조 사용의 중요성
언제 어떤 구조를 사용하면 좋을지, 언제는 그렇지 않을지에 대한 논의는 항상 있을 것입니다. 
이를 균형있게 판단하는 것이 중요합니다. 
서로 다른 구조가 어떻게 복잡성을 도입하거나 어떻게 이를 명확하게 하는지를 인지하는 것이 중요합니다. 
특히 두 구조를 함께 사용할 때, 두 구조의 복잡성은 일반적으로 각각의 복잡성을 더한 것보다 훨씬 더 클 수 있습니다.

---

## 관습 및 안좋은 예시
사람들은 가독성에 대해 서로 다양한 사례를 빗대어 논쟁을 하고 있습니다. 
- 함수 이름에 대한 논쟁
- 명시적이어야 하는 것과 암시적이어야 하는 것에 대한 논의 
- 사용해야 할 관용어는 무엇인지 
 
위와 같은 사례들과는 별개로 Kotlin에서는 기본적으로 이해하고 기억해야 할 몇 가지 관습(`Conventions`)들이 있습니다.

### Kotlin 코드의 안좋은 예시

```kotlin
val abc = "A" { "B" } and "C"
print(abc) //ABC
```

```kotlin 
operator fun String.invoke(f: ()-> String): String = this + f()
infix fun String.and(s:String) = this+s
```

이 코드는 다음과 같은 여러 가지 규칙을 위반합니다.

- 연산자의 의미를 위반합니다 - [invoke](../용어.md#invoke-연산자)는 이런 방식으로 사용되어서는 안 됩니다.
  - 문자열에 대해서는 이러한 방식으로 사용될 수 없습니다. 문자열은 함수가 아니며 호출할 수 있는 동작이 없습니다.
- 여기서 [마지막 인자로 람다](../용어.md#마지막-인자로-람다)를 사용하는 방법에 문제가 있습니다.
  - 함수의 이름이나 동작을 통해 람다의 목적을 이해할 수 있는 경우에 사용해야 합니다. 
  - `invoke` 연산자에서 람다를 사용하는 것은 람다의 목적이 분명하지 않아 보입니다.
- 함수 이름 `and`는 이 [infix](../용어.md#infix-키워드)에 대해 좋지 못한 이름입니다.
  - `and`라는 이름은 보통 논리연산에 사용되므로 문자열 연결하는 연산에 적합하지 못합니다. 
  - 차라리 `append` 또는 `plus`가 훨씬 나았을 것입니다.
- 문자열 연결을 위한 언어 기능이 이미 있으므로, 이를 다시 개발할 필요는 없습니다.
  - `+` 연산자를 사용하거나, `concat`함수를 사용하거나, 문자열 템플릿을 사용할 수 있습니다.