# 목차

- [Item 11 : 가독성을 위한 설계](#item-11--가독성을-위한-설계)
- [Item 12 : 연산자 의미 == 함수 이름](#item-12--연산자의-의미--함수-이름)
- [Item 13 : Unit? 반환 대신 Boolean 사용](#item-13-unit-반환-대신-boolean-사용)
- [Item 14 : 변수 타입이 명확하지 않은 경우 지정하자](#item-14--변수-타입이-명확하지-않은-경우-지정하자)
- [Item 15 : Receiver의 명시적 참조 중요성](#item-15--receiver의-명시적-참조-중요성)
- [Item 16 : Property는 행동이 아닌 상태를 나타내야한다](#item-16--property는-행동이-아닌-상태를-나타내야한다)
---

# Item 11 : 가독성을 위한 설계

### 인지 부하 줄이기

- 복잡한 코드는 인지 부하를 증가시키므로, 익숙한 패턴을 사용해 가독성을 높이는 것이 좋습니다.
- 모든 개발자들에게 익숙한 `if/else` 문법을 통한 예시와 Kotlin `scope` 함수에 대한 문법을 비교

### 극단적인 접근 피하기

- 불필요한 복잡성은 피하되, 때로는 코드를 개선하기 위해 복잡성이 필요할 수 있습니다. 이 때는 균형을 잘 유지해야 합니다.
- 너무 복잡한 함수 체이닝은 피하되, 적절하게 사용하면 가독성을 높일 수 있습니다.

### Conventions (관습)

- 코드 가독성과 유지보수를 위해 코틀린의 관습을 따르는 것이 중요합니다.
- 연산자들의 약속된 사용방식을 지킵니다.
- 함수 이름을 정할 때 적절한 함수 이름인지 확인합니다.
- 이미 있는 Kotlin에서 지원하는 기능이 있는 경우 최대한 활용합니다.

# Item 12 : 연산자의 의미 == 함수 이름

### 연산자 오버로딩
연산자 오버로딩은 강력하지만 잘못 사용되면 혼동을 야기할 수 있습니다. 이는 함수의 이름이 그 기능과 일치하지 않을 때 발생합니다.   
예를 들어, 논리적 'not' 연산자를 팩토리얼 계산에 사용하는 것은 혼란스러울 수 있습니다.

### 연산자의 의미
Kotlin에서는 각 연산자가 구체적인 의미를 가집니다.   
연산자의 의미가 불분명할 경우, 명확한 이름을 가진 일반 함수를 사용하거나, 연산자처럼 보이는 구문을 원한다면 `infix` 또는 상위 수준의 함수를 사용하면 됩니다. 

위 '연산자의 의미와 함수 이름이 같아야 한다'는 규칙을 깨도 되는 경우는 `DSL`를 설계할 때입니다.

---

# Item 13: Unit? 반환 대신 Boolean 사용

### Unit?과 Boolean 동치성
Kotlin에서 `Unit?`은 `Boolean`과 동치성을 가지며 대신하여 로직을 표현하는데 사용할 수 있습니다.

### Unit?의 잘못된 사용
그러나, 잘못 사용될 경우 로직을 이해하는데 혼동을 줄 수 있습니다.

    getData()?.let { view.showData(it) } ?: view.showError()

위와 같이 `view.ShowData()`에서 `null`이 반환되는 경우를 가정하면 `view.ShowError()`가 실행될 수 있으므로
`getData()`의 `null` 상황과 `view.ShowData()`의 `null` 상황을 구분하기 어렵습니다.

위와 같은 경우 `Unit?` 대신 표준적인 `if-else` 구문을 사용하는 것이 가독성을 향상시키며 혼란을 줄일 수 있습니다.

### Unit? 대신 Boolean 사용 권장
일반적으로 `Unit?`을 `return` 하거나 연산하는 작업을 피하도록하고, 만약 그렇게 되어 있다면 `Boolean`으로 대체하는 것이 좋습니다.

---

# Item 14 : 변수 타입이 명확하지 않은 경우 지정하자

## 타입 추론과 가독성
Kotlin은 타입 추론 시스템이 잘 발달해 있어, 문맥상 타입이 명확한 경우에는 생략할 수 있습니다. 
이는 개발 시간과 가독성 향상에 도움이 됩니다.

## 타입 명시의 중요성
그러나, 타입이 명확하지 않은 경우 이러한 방식을 과도하게 사용하면 문제가 발생할 수 있습니다. 
함수 세부사항을 확인하려는 독자에게 필요한 정보를 숨기는 것은 좋지 않습니다.

## 안전성과 타입 명시
가독성 향상 뿐 아니라, 타입 명시는 컴파일러에게도 중요한 정보를 제공하며 코드의 안전성을 높이는데 기여합니다. 
타입은 중요한 정보이므로, 명확하지 않을 경우에는 명시하는것이 좋습니다.

---

# Item 15 : Receiver의 명시적 참조 중요성

## 리시버의 사용과 가독성
Kotlin에서 함수나 속성이 객체로부터 가져오는 것을 명확하게 나타내기 위해 리시버를 명시적으로 참조할 수 있습니다. 이는 코드의 가독성을 높이는 데 도움이 됩니다.

```kotlin
class User: Person() {
    private var beersDrunk: Int = 0
    
    fun drinkBeers(num: Int) {
        this.beersDrunk += num
    }
}
```

## 확장 리시버의 명시적 사용
확장 리시버를 명시적으로 참조하여 코드를 작성하면, 작성하려는 의도를 더 명확하게 표현할 수 있습니다.

```kotlin
fun <T: Comparable<T>> List<T>.quicksort(): List<T> {
    if (size < 2) return this
    val pivot = this.first()
    val (smaller, bigger) = drop(1).partition { it < pivot }
    return smaller.quickSort() + pivot + bigger.quickSort()
}
```

## 여러 리시버와의 상호작용
여러 리시버의 범위를 갖는 상황에 놓일 수 있는 `apply`, `with`, `run` 함수를 사용할 때에는, 명시적 리시버를 사용하여 안전하게 코드를 작성하는 것이 좋습니다.

```kotlin
class Node(val name: String) {
    fun makeChild(childName: String) =
        create("$name.$childName").apply { print("Created ${this?.name}") }
        
    fun create(name: String): Node? = Node(name)
}

fun main(){
    val node = Node("parent") 
    node.makeChild("child") // "Created parent.child" 출력
}
```

## 라벨을 이용한 리시버 명시
리시버가 어떤 것을 가리키는지 명확하지 않은 경우에는, 리시버를 피하거나 명시적으로 리시버를 사용해 명확하게 표현해야 합니다. 라벨을 사용하면 원하는 리시버를 정확히 참조할 수 있습니다.

```kotlin
class Node(val name: String) {
    fun makeChild(childName: String) =
        create("$name.$childName").apply { 
            print("Created ${this.name} in ${this@Node.name}")
        }
        
    fun create(name: String): Node? = Node(name)
}

fun main(){
    val node = Node("parent") 
    node.makeChild("child") // "Created parent.child in parent" 출력
}
```

# Item 16 : Property는 행동이 아닌 상태를 나타내야한다.

## 속성과 백업 필드
Kotlin의 속성(Property)은 데이터를 보유하는 방식이 Java의 필드(Field)와 비슷하며, 추가적으로 사용자 정의 `setter`와 `getter`를 제공합니다.  
컴파일러는 속성에 대한 `백업 필드`를 자동으로 생성하게 됩니다. 이 백업 필드는 `field` 키워드를 통해 접근할 수 있습니다.

## 파생 속성
파생 속성(Derived Properties)은 다른 속성이나 변수, 연산에 기반한 속성을 말합니다.   
이는 코드의 가독성을 향상시키고, 캡슐화를 쉽게하며, 데이터 타입의 변경에 쉽게 대응할 수 있게 합니다.

## 속성 사용 주의점
속성 접근자는 속성에 접근하는 함수로, 이를 통해 속성을 재정의하거나 다른 객체에게 위임할 수 있습니다.   
하지만, 속성은 알고리즘적인 행동을 나타내는 데 사용되어서는 안되며, 복잡한 로직이나 계산이 포함되어서도 안됩니다.

또한 **속성 사용을 피해야하는** 몇가지 상황은 다음과 같습니다.
- 비용이 많이 드는 연산을 수행해야 하는 상황
- 비지니스 로직이 포함되어 있는 상황
- 결과가 변하는 상황
- 실생순서가 중요한 로직을 수행하는 상황
- 형변환이 필요한 상황
- Getter가 상태를 변경하는 상황

